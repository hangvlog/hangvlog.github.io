<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ES6复习</title>
      <link href="/2023/04/24/ES6%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/04/24/ES6%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>ES6复习</p><p>计算机网络</p><p><a href="https://juejin.cn/post/6908327746473033741">「2021」高频前端面试题汇总之计算机网络篇 - 掘金 (juejin.cn)</a></p><p><a href="https://zhuanlan.zhihu.com/p/237948931#:~:text=面试汇总 (三">面试汇总(三)：计算机网络常见面试总结(一) - 知乎 (zhihu.com)</a>：计算机网络常见面试总结 (一) 1 1、请你说一下TCP怎么保证可靠性，并且简述一下TCP建立连接和断开连接的过程 TCP保证可靠性： （1）序列号、确认应答、超时重传%3A 数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一次需要接收的数据序列号。,3、请回答一下HTTP和HTTPS的区别，以及HTTPS有什么缺点？ HTTP协议和HTTPS协议区别如下： 1）HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性 … 4 4、请你说一说HTTP返回码 HTTP协议的响应报文由状态行、响应头部和响应包体组成，其响应状态码总体描述如下： )</p><p><a href="https://jerryc8080.gitbooks.io/understand-tcp-and-udp/content/chapter1.html">（一）TCP 端口 · 理解 TCP 和 UDP (gitbooks.io)</a></p><h3 id="apply求数组的最大值与最小值"><a href="#apply求数组的最大值与最小值" class="headerlink" title="apply求数组的最大值与最小值"></a><code>apply</code>求数组的最大值与最小值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">33</span>,<span class="number">4</span>,<span class="number">52</span>,<span class="number">17</span>]</span><br><span class="line"><span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, arr)</span><br><span class="line"><span class="title class_">Math</span>.<span class="property">min</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, arr)</span><br></pre></td></tr></table></figure><h1 id="for循环相关"><a href="#for循环相关" class="headerlink" title="for循环相关"></a>for循环相关</h1><h2 id="var与let"><a href="#var与let" class="headerlink" title="var与let"></a>var与let</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h2 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ开始</span></span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ结束</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// undefined</span></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于<code>var</code>声明的变量。上面的例子实际运行的代码如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">f</span>();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure><ul><li>ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种写法，报错</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 第二种写法，不报错</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>const 声明的变量，一旦声明必须初始化，而且之后不能修改对于数据的栈的引用（因为js将我们的对象类型的具体数据放在堆中，同时在栈中存放一份引用）,这个在栈中的引用我们不能修改，但是堆中的数据我们可以进行修改【简单的例子数组修改某一个位置的元素】</p><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p><code>var</code>命令和<code>function</code>命令。ES6 除了添加<code>let</code>和<code>const</code>命令，后面章节还会提到，另外两种声明变量的方法：<code>import</code>命令和<code>class</code>命令。所以，ES6 一共有 6 种声明变量的方法。</p><h1 id="补充基础"><a href="#补充基础" class="headerlink" title="补充基础"></a>补充基础</h1><h2 id="typeof和instanceof区别"><a href="#typeof和instanceof区别" class="headerlink" title="typeof和instanceof区别"></a>typeof和instanceof区别</h2><p>typeof*(不能区分Object，null和array)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Numbers </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">37</span> === <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line"><span class="comment">// Strings </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;&quot;</span> === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"><span class="comment">// Booleans </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> === <span class="string">&#x27;boolean&#x27;</span>;</span><br><span class="line"><span class="comment">// Symbols </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>) === <span class="string">&#x27;symbol&#x27;</span>;</span><br><span class="line"><span class="comment">// Undefined </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> === <span class="string">&#x27;undefined&#x27;</span>; </span><br><span class="line"><span class="keyword">typeof</span> blabla === <span class="string">&#x27;undefined&#x27;</span>; <span class="comment">// 一个未定义的变量,或者一个定义了却未赋初值的变量</span></span><br><span class="line"><span class="comment">// Objects </span></span><br><span class="line"><span class="keyword">typeof</span> &#123;<span class="attr">a</span>:<span class="number">1</span>&#125; === <span class="string">&#x27;object&#x27;</span>;</span><br><span class="line">------------------------<span class="string">&#x27;下面是不是有点奇怪？&#x27;</span>--------------------------</span><br><span class="line">type [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] = <span class="string">&#x27;object&#x27;</span></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; === <span class="string">&#x27;function&#x27;</span>;</span><br><span class="line"><span class="comment">// Null</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">&#x27;object&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>所有返回值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42</span> <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42n</span> <span class="comment">// &quot;bigint&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;Hello World&quot;</span> <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>() <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125; <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure><p>问题：</p><p>无法区分对象，数组，NULL（这个将永远无法修复）</p><h3 id="问题产生原因"><a href="#问题产生原因" class="headerlink" title="问题产生原因"></a>问题产生原因</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">js通过数据前3位判断数据类型</span><br><span class="line"></span><br><span class="line">而我们的数组和对象前3位都是0，只要前三位是0，那么就是对象类型</span><br><span class="line"></span><br><span class="line">至于null为何typeof也是Object是由于null二进制存储是全0，前三位自然也是0</span><br></pre></td></tr></table></figure><p>对于如何区分这三种类型也有办法就是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> test) === <span class="string">&#x27;Object&#x27;</span>&#123;</span><br><span class="line">    <span class="comment">//Object.prototype.toString.call(arr) // &quot;[object Array]&quot;</span></span><br><span class="line"><span class="comment">//Object.prototype.toString.call(obj) // &quot;[object Object]&quot;</span></span><br><span class="line">    <span class="comment">//Object.prototype.toString.call(null) &#x27;[object Null]&#x27;</span></span><br><span class="line">    这种方法解决了<span class="keyword">typeof</span>无法准确判断类型的问题</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>好处：</p><p>能判断一个变量是否被定义</p><p>instanceof</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">d <span class="keyword">instanceof</span> <span class="title class_">Date</span>; <span class="comment">// true</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="title class_">Object</span>; <span class="comment">// true (所有对象都是 Object 的实例)</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="title class_">Array</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>手写indtanceof</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myInstanceOf = <span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = a</span><br><span class="line">  <span class="keyword">while</span>(tmp.<span class="property">__proto__</span>  != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (tmp.<span class="property">__proto__</span> == b.<span class="property"><span class="keyword">prototype</span></span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    tmp = tmp.<span class="property">__proto__</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// a = [1,2,3]</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">// a = new Object()</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line">a = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceOf</span>(a,<span class="title class_">Object</span>));</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">instance_of</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> leftVal = left.<span class="property">__proto__</span>;</span><br><span class="line">  <span class="keyword">let</span> rightVal = right.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftVal === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (leftVal === rightVal) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    leftVal = leftVal.<span class="property">__proto__</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">name</span>: <span class="string">&#x27;冯总&#x27;</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">instance_of</span>(a, <span class="title class_">Object</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><ul><li>typeof会返回一个变量的基本类型（结果是一个字符串），instanceof返回的是一个布尔值</li><li>instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型</li><li>而typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了function 类型以外，其他的也无法判断</li></ul><h2 id="和-区别"><a href="#和-区别" class="headerlink" title="==和===区别"></a>==和===区别</h2><p><code>===</code> 严格相等，会比较两个值的类型和值 </p><p><code>==</code>  抽象相等，比较时，会先进行类型转换，然后再比较值</p><p><strong>再说 ==，根据以下规则：</strong></p><p>1、如果两个值类型相同，进行 === 比较。</p><p>2、如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较：</p><p>a、如果一个是null、一个是undefined，那么[相等]。</p><p>b、如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。</p><p>c、如果任一值是 true ，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。</p><p>d、如果一个是对象，另一 个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的toString或者valueOf方法。js核心内置类，会尝试 valueOf先于toString；例外的是Date，Date利用的是toString转换。非js核心的对象，令说（比较麻烦，我也不大懂）</p><p>e、任何其他组合，都[不相等]。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span> == <span class="string">&quot;5&quot;</span>); <span class="comment">// true, 字符串被转换为数字5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> == <span class="number">1</span>); <span class="comment">// true, 布尔值被转换为数字1</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">// true, 它们相等</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;5&quot;</span> == [<span class="number">5</span>]); <span class="comment">// true, 数组转换为字符串&quot;5&quot;，然后和字符串&quot;5&quot;比较</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; == &#123;&#125;); <span class="comment">// false, 两个不同的对象不能相等</span></span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>总之，建议在比较两个值时始终使用===运算符，以避免可能出现的类型转换问题。</p><h2 id="对象的valueOf和toString"><a href="#对象的valueOf和toString" class="headerlink" title="对象的valueOf和toString"></a>对象的valueOf和toString</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">10</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">valueOf</span>()); <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>()); <span class="comment">// &quot;10&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">valueOf</span>()); <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">toString</span>()); <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">valueOf</span>()); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">toString</span>()); <span class="comment">// &quot;1,2,3</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(add.<span class="title function_">valueOf</span>()); <span class="comment">// function add(x, y) &#123; return x + y; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(add.<span class="title function_">toString</span>()); <span class="comment">// &quot;function add(x, y) &#123; return x + y; &#125;&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">valueOf</span>()); <span class="comment">// &#123; name: &quot;Alice&quot;, age: 25 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">toString</span>()); <span class="comment">// &quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now.<span class="title function_">valueOf</span>()); <span class="comment">// 1648202702626</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now.<span class="title function_">toString</span>()); <span class="comment">// &quot;Fri Mar 25 2022 16:45:02 GMT+0800 (中国标准时间)&quot;</span></span><br></pre></td></tr></table></figure><p>通常情况下，我们不需要使用<code>valueOf()</code>和<code>toString()</code>方法来操作<code>function</code>和<code>object</code>对象，因为它们的默认实现已经很好地满足了我们的需求。但是，在某些特定的场景下，例如需要将函数转换为字符串或需要将对象转换为原始值时，可以使用<code>valueOf()</code>和<code>toString()</code>方法来实现自定义的类型转换。</p><h2 id="为什么script标签要写到body标签的底部"><a href="#为什么script标签要写到body标签的底部" class="headerlink" title="为什么script标签要写到body标签的底部"></a>为什么script标签要写到body标签的底部</h2><p><a href="https://zhuanlan.zhihu.com/p/268048119">探究: 为什么JavaScript要在body标签尾部引入? - 知乎 (zhihu.com)</a></p><p>首先说下网页解析流程</p><ol><li><strong>Parse HTML</strong> 该阶段生成了DOM Tree和CSSOM Tree;</li><li><strong>Layout</strong> 将DOM Tree结合CSSOM Tree, 生成Layout Tree(又称Render Tree), 计算每个元素的尺寸和位置;</li><li><strong>Update Layout Tree</strong> 更新Layout Tree;</li><li><strong>Paint</strong> 生成PaintLayout Tree记录元素绘制顺序;</li><li><strong>Composite</strong> 合成视图输出到屏幕;</li></ol><p>js无论是放在head标签里还是body标签里都会阻塞HTML的解析、渲染</p><p>例外：js通过外部引入的方式时，此时js的下载会阻塞HTML的解析，但是不会阻塞HTML的渲染，知道js文件下载并执行结束之后HTML才会继续解析并渲染</p><p>别人的看法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">JS</span> 放在底部可以保证让浏览器优先渲染完现有的 <span class="variable constant_">HTML</span> 内容，让用户先看到内容，体验好。另外，<span class="variable constant_">JS</span> 执行如果涉及 <span class="variable constant_">DOM</span> 操作，得等待 <span class="variable constant_">DOM</span> 解析完成才行，<span class="variable constant_">JS</span> 放在底部执行时，<span class="variable constant_">HTML</span> 肯定都解析成了 <span class="variable constant_">DOM</span> 结构。</span><br><span class="line"><span class="comment">//JS 如果放在 HTML 顶部，JS 执行的时候 HTML 还没来得及转换为 DOM 结构，可能会报错。</span></span><br></pre></td></tr></table></figure><h2 id="CSS的link导入和import导入区别"><a href="#CSS的link导入和import导入区别" class="headerlink" title="CSS的link导入和import导入区别"></a>CSS的link导入和import导入区别</h2><ul><li>1、从属关系：link是html的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等；而@import是css的语法，只有导入样式表的作用。</li><li>2、加载顺序：页面被加载时，link会和html同时被加载而；@import引入的 CSS 将在页面加载完毕后被加载。</li><li>3、兼容性：@import是 CSS2.1 才有的语法，所以只能在 IE5以上 才能识别；而link是 HTML 标签，所以不存在兼容性问题。</li><li>4、DOM：javascript只能控制dom去改变link标签引入的样式，而@import的样式不是dom可以控制的。</li><li>5、link方式的样式权重高于@import的权重。（如果对权重不是十分了解，可以看我之前的文章）</li></ul><h2 id="TCP的可靠交付实现"><a href="#TCP的可靠交付实现" class="headerlink" title="TCP的可靠交付实现"></a>TCP的可靠交付实现</h2><h1 id="突然想到的面试题"><a href="#突然想到的面试题" class="headerlink" title="突然想到的面试题"></a>突然想到的面试题</h1><h2 id="数组、字符串的方法"><a href="#数组、字符串的方法" class="headerlink" title="数组、字符串的方法"></a>数组、字符串的方法</h2><h2 id="js的严格模式"><a href="#js的严格模式" class="headerlink" title="js的严格模式"></a>js的严格模式</h2><p>函数的声明只能在当前作用域的最顶层</p><p>函数不是作为对象的方法运行，而是单纯作为函数运行，<code>this</code>会指向顶层对象。但是，严格模式下，这时<code>this</code>会返回<code>undefined</code>。</p><h2 id="各种数据类型的内存存放"><a href="#各种数据类型的内存存放" class="headerlink" title="各种数据类型的内存存放"></a>各种数据类型的内存存放</h2><ul><li>基本类型（Primitive types）：包括数字、字符串、布尔值、null 和 undefined，它们都存储在栈内存中。</li><li>对象类型（Object types）：包括对象、数组和函数，它们都存储在堆内存中。</li><li>函数类型（Function types）：函数是对象的一种，所以它们的内存分配方式与其他对象相同，函数的函数体存储在堆内存中，但函数的引用（指针）会存储在栈内存中。</li><li>引用类型（Reference types）：包括对象、数组、函数等，它们在栈内存中存储一个引用，指向它们在堆内存中的位置。</li></ul><h2 id="js获取对象属性的两种方法"><a href="#js获取对象属性的两种方法" class="headerlink" title="js获取对象属性的两种方法"></a>js获取对象属性的两种方法</h2><p>.属性名和[属性名]</p><p>方括号表示法在以下情况下特别有用：</p><ul><li>属性名包含空格或特殊字符</li><li>属性名保存在变量中，需要动态获取属性值的情况。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="string">&#x27;full name&#x27;</span>: <span class="string">&#x27;John Smith&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person[<span class="string">&#x27;full name&#x27;</span>]); <span class="comment">// 输出 &#x27;John Smith&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> propName = <span class="string">&#x27;age&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person[propName]); <span class="comment">// 输出 undefined，因为 age 属性不存在</span></span><br></pre></td></tr></table></figure><p>不同</p><ul><li>在使用方括号表示法时，如果属性名不存在，会返回 undefined。而在使用点号表示法时，如果属性名不存在，会抛出一个错误</li></ul><p>点号表示法</p><ul><li>语法简单明了，直观易懂。</li><li>属性名必须是一个合法的标识符，不能包含空格、特殊字符等。</li><li>不能使用变量动态获取属性名。</li></ul><p>方括号表示法</p><ul><li>属性名可以是任何字符串，包括包含空格、特殊字符的字符串。</li><li>可以使用变量动态获取属性名。</li><li>语法稍显复杂，不如点号表示法直观。</li></ul><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><h2 id="为什么ES6的class是一个语法糖（或者async）"><a href="#为什么ES6的class是一个语法糖（或者async）" class="headerlink" title="为什么ES6的class是一个语法糖（或者async）"></a>为什么ES6的class是一个语法糖（或者async）</h2><h3 id="ES5手动实现继承"><a href="#ES5手动实现继承" class="headerlink" title="ES5手动实现继承"></a>ES5手动实现继承</h3><ul><li>方法1</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类方法</span></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, I&#x27;m &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="comment">// 调用父类构造函数</span></span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类继承父类的原型</span></span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Cat</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类方法</span></span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">meow</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Meow, I&#x27;m &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;Kitty&quot;</span>);</span><br><span class="line">cat.<span class="title function_">sayHello</span>(); <span class="comment">// 输出 &quot;Hello, I&#x27;m Kitty&quot;</span></span><br><span class="line">cat.<span class="title function_">meow</span>(); <span class="comment">// 输出 &quot;Meow, I&#x27;m Kitty&quot;</span></span><br></pre></td></tr></table></figure><ul><li>还有一个方法是借助<strong>Object.setPrototypeOf(obj1, obj2)</strong></li></ul><p><code>Object.setPrototypeOf()</code> 方法是在 ECMAScript 6 （也称为 ES2015）中引入的，因此它在2015年之后的浏览器和 JavaScript 环境中可用。</p><p>在 ES6 之前，我们通常使用 <code>Object.create()</code> 方法来创建一个新对象，并将其原型设置为另一个对象。<code>Object.setPrototypeOf()</code> 方法的出现提供了一种更方便的方法来实现对象之间的继承关系。</p><p>需要注意的是，虽然 <code>Object.setPrototypeOf()</code> 方法非常方便，但是它也有一些性能问题，因为它会影响到对象的性能。因此，在实现继承时，建议使用其他更有效的方式，例如使用类或构造函数来创建对象。</p><ul><li>利用Object.create()【看错了，这个就是第一种方法】</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义父对象</span></span><br><span class="line"><span class="keyword">var</span> parent = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Parent&quot;</span>,</span><br><span class="line">  <span class="attr">sayHello</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, I&#x27;m &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子对象</span></span><br><span class="line"><span class="keyword">var</span> child = <span class="title class_">Object</span>.<span class="title function_">create</span>(parent);</span><br><span class="line">child.<span class="property">name</span> = <span class="string">&quot;Child&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用父对象的方法</span></span><br><span class="line">child.<span class="title function_">sayHello</span>(); <span class="comment">// 输出：Hello, I&#x27;m Child</span></span><br></pre></td></tr></table></figure><h3 id="ES5和ES6的继承区别"><a href="#ES5和ES6的继承区别" class="headerlink" title="ES5和ES6的继承区别"></a>ES5和ES6的继承区别</h3><p>ES5的继承时通过prototype或构造函数机制来实现。<strong>ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上</strong>（Parent.apply(this)）。</p><p>ES6的继承机制完全不同，<strong>实质上是先创建父类的实例对象this（所以必须先调用父类的super()方法），然后再用子类的构造函数修改this</strong>。</p><p>具体的：ES6通过class关键字定义类，里面有构造方法，类之间通过extends关键字实现继承。子类必须在constructor方法中调用super方法，否则新建实例报错。因为子类没有自己的this对象，而是继承了父类的this对象，然后对其进行加工。如果不调用super方法，子类得不到this对象。</p><p>ps：super关键字指代父类的实例，即父类的this对象。在子类构造函数中，调用super后，才可使用this关键字，否则报错。</p><h2 id="手撕New"><a href="#手撕New" class="headerlink" title="手撕New"></a>手撕New</h2><ol><li>创建一个新的空对象</li><li>将空对象的<code>__proto__</code>指向构造函数的<code>prototype</code>。</li><li>将这个空对象赋值给构造函数内部的<code>this</code>，并执行构造函数。</li><li>如果返回值是一个对象就返回该对象，否则返回构造函数的一个实例对象</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">Con, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 创建一个新的空对象</span></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="comment">// 2. 将空对象的 __proto__ 指向构造函数的原型</span></span><br><span class="line">  obj.<span class="property">__proto__</span> = <span class="title class_">Con</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="comment">// 3. 将this指向空对象</span></span><br><span class="line">  <span class="keyword">let</span> res = <span class="title class_">Con</span>.<span class="title function_">apply</span>(obj, args);</span><br><span class="line">  <span class="comment">// 4. 对构造函数返回值做判断，然后返回对应的值</span></span><br><span class="line">  <span class="keyword">return</span> res <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? res : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用实例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Demo</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test = <span class="title function_">myNew</span>(<span class="title class_">Demo</span>, <span class="string">&quot;useNew&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test); <span class="comment">// Demo &#123;name: &#x27;useNew&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test.<span class="property">__proto__</span> === <span class="title class_">Demo</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>另外一种方式</p><ul><li>创建了一个空对象，对象的<code>__proto__-&gt;Thin_User.prototype</code></li><li>执行构造函数，并将<code>this</code>指向新对象</li><li>返回新对象</li></ul><p>此外当构造函数返回值为对象时，直接返回这个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createObject</span>(<span class="params">Con</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建新对象obj</span></span><br><span class="line">    <span class="comment">// var obj = &#123;&#125;;也可以</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将obj.__proto__ -&gt; 构造函数原型</span></span><br><span class="line">    <span class="comment">// (不推荐)obj.__proto__ = Con.prototype</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, <span class="title class_">Con</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行构造函数，并接受构造函数返回值</span></span><br><span class="line">    <span class="keyword">const</span> ret = <span class="title class_">Con</span>.<span class="title function_">apply</span>(obj, [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若构造函数返回值为对象，直接返回该对象</span></span><br><span class="line">    <span class="comment">// 否则返回obj</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">typeof</span>(ret) === <span class="string">&#x27;object&#x27;</span> ? <span class="attr">ret</span>: obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手撕继承"><a href="#手撕继承" class="headerlink" title="手撕继承"></a>手撕继承</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>对于父类，我们直接使用正常方法：</p><ul><li>方法：把我们要继承的方法挂到父类的原型上</li><li>属性：直接在父类的构造函数里面传参</li></ul><p>对于子类：</p><ul><li>构建原型对象，并指向父类的实例</li><li><del>为原型对象添加指向父类的原型的<strong>proto</strong>指针</del></li><li>为原型对象添加constructor指针，指向我们的子类的构造函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;写代码像蔡徐抻&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类的原型方法</span></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让子类的原型对象指向父类实例, 这样一来在Child实例中找不到的属性和方法就会到原型对象(父类实例)上寻找</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>()</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span> <span class="comment">// 根据原型链的规则,顺便绑定一下constructor, 这一步不影响继承, 只是在用到constructor时会需要</span></span><br><span class="line"><span class="comment">//Child.prototype.__proto__ = Parent().prototype //原型对象添加指向父类的原型的__proto__指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后Child实例就能访问到父类及其原型上的name属性和getName()方法</span></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line">child.<span class="property">name</span>          <span class="comment">// &#x27;写代码像蔡徐抻&#x27;</span></span><br><span class="line">child.<span class="title function_">getName</span>()     <span class="comment">// &#x27;写代码像蔡徐抻&#x27;</span></span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>由于所有Child实例原型都指向同一个Parent实例, 因此对某个Child实例的父类引用类型变量修改会影响所有的Child实例<br>在创建子类实例时无法向父类构造传参, 即没有实现super()的功能</li></ul><h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = [name]</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="string">&#x27;zhangsan&#x27;</span>)   <span class="comment">// 执行父类构造方法并绑定子类的this, 使得父类中的属性能够赋到子类的this上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">const</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line"><span class="keyword">const</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line">child1.<span class="property">name</span>[<span class="number">0</span>] = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">name</span>)          <span class="comment">// [&#x27;foo&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">name</span>)          <span class="comment">// [&#x27;zhangsan&#x27;]</span></span><br><span class="line">child2.<span class="title function_">getName</span>()                  <span class="comment">// 报错,找不到getName(), 构造函数继承的方式继承不到父类原型上的属性和方法</span></span><br></pre></td></tr></table></figure><p><strong>构造函数继承的缺点:</strong></p><ul><li>继承不到父类原型上的属性和方法</li></ul><h3 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = [name]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//挂载到原型上，实现方法的继承</span></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 构造函数继承 实现类似于super的效果</span></span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="string">&#x27;zhangsan&#x27;</span>) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型链继承 </span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>()</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">const</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line"><span class="keyword">const</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line">child1.<span class="property">name</span>[<span class="number">0</span>] = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">name</span>)          <span class="comment">// [&#x27;foo&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">name</span>)          <span class="comment">// [&#x27;zhangsan&#x27;]</span></span><br><span class="line">child2.<span class="title function_">getName</span>()                  <span class="comment">// [&#x27;zhangsan&#x27;]</span></span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>不够优雅，子类在继承时会调用2次父类方法</li></ul><h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = [name]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类方法的继承</span></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 构造函数继承 父类属性的继承</span></span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="string">&#x27;zhangsan&#x27;</span>) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型链继承</span></span><br><span class="line"><span class="comment">// Child.prototype = new Parent()</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>  <span class="comment">//将`指向父类实例`改为`指向父类原型`</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">const</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line"><span class="keyword">const</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line">child1.<span class="property">name</span>[<span class="number">0</span>] = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">name</span>)          <span class="comment">// [&#x27;foo&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">name</span>)          <span class="comment">// [&#x27;zhangsan&#x27;]</span></span><br><span class="line">child2.<span class="title function_">getName</span>()                  <span class="comment">// [&#x27;zhangsan&#x27;]</span></span><br></pre></td></tr></table></figure><p>问题：由于子类原型和父类原型指向同一个对象</p><h3 id="最终版"><a href="#最终版" class="headerlink" title="最终版"></a>最终版</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = [name]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类方法的继承</span></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 构造函数继承 父类属性的继承</span></span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="string">&#x27;zhangsan&#x27;</span>) </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型链继承 利用对象的浅拷贝</span></span><br><span class="line"><span class="comment">// Child.prototype = new Parent()</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>)  <span class="comment">//将`指向父类实例`改为`指向父类原型` ***</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line"><span class="keyword">const</span> parent = <span class="keyword">new</span> <span class="title class_">Parent</span>()</span><br><span class="line">child.<span class="title function_">getName</span>()                  <span class="comment">// [&#x27;zhangsan&#x27;]</span></span><br><span class="line">parent.<span class="title function_">getName</span>()                 <span class="comment">// 报错, 找不到getName()</span></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>继承父类的属性，通过在子类的构造函数内部调用Father.call(this,arg1,arg2)</li><li>继承父类的方法：直接父类将方法挂载到原型上</li><li>继承父类的原型链：1.子类构造方法添加原型对象，原型对象指向构造函数</li></ul><h2 id="手撕call，apply，bind"><a href="#手撕call，apply，bind" class="headerlink" title="手撕call，apply，bind"></a>手撕call，apply，bind</h2><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>所以<code>call</code>的模拟思想为下面三步：</p><ul><li>将函数<code>fn</code>设为<code>thisArg</code>的对象的方法</li><li>执行<code>thisArg.fn</code></li><li>删除该函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">thisArg</span>) &#123;</span><br><span class="line">    <span class="comment">// this为调用myCall的函数</span></span><br><span class="line">    thisArg.<span class="property">func</span> = <span class="variable language_">this</span>;</span><br><span class="line">    thisArg.<span class="title function_">func</span>();</span><br><span class="line">    <span class="title function_">delete</span>(thisArg.<span class="property">func</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完善</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">thisArg</span>) &#123;</span><br><span class="line">    <span class="comment">//浏览器环境下，由于call方法的第一个参数可以不传</span></span><br><span class="line">    thisArg = thisArg || <span class="variable language_">window</span>;</span><br><span class="line">    thisArg.<span class="property">func</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">//将伪数组转为真数组</span></span><br><span class="line">    <span class="keyword">const</span> args = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i&lt;<span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        args.<span class="title function_">push</span>(<span class="string">&#x27;arguments[&#x27;</span>+ i + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    【<span class="variable language_">arguments</span>[<span class="number">0</span>],<span class="variable language_">arguments</span>[<span class="number">1</span>]】</span><br><span class="line">    <span class="comment">//执行函数</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">eval</span>(<span class="string">&#x27;thisArg.func(&#x27;</span> + args +<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> thisArg.<span class="property">func</span>;</span><br><span class="line">    <span class="comment">//拿到函数执行的结果就是返回值</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>在函数的原型上添加myCall方法</li><li>拷贝并执行this</li><li>删除</li></ul><p>ES6版本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">thisArg, ...args</span>) &#123;</span><br><span class="line">    thisArg = thisArg || <span class="variable language_">window</span>;</span><br><span class="line">    thisArg.<span class="property">func</span> = <span class="variable language_">this</span>;</span><br><span class="line">    args = args || []</span><br><span class="line">    <span class="keyword">const</span> result = thisArg.<span class="title function_">func</span>(..<span class="property">args</span>)</span><br><span class="line">    <span class="keyword">delete</span> thisArg.<span class="property">func</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手撕apply"><a href="#手撕apply" class="headerlink" title="手撕apply"></a>手撕apply</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params">thisArg, arr</span>) &#123;</span><br><span class="line">    thisArg = thisArg || <span class="variable language_">window</span>;</span><br><span class="line">    thisArg.<span class="property">func</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> args = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        args.<span class="title function_">push</span>(<span class="string">&#x27;arr[&#x27;</span>+ i + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">eval</span>(<span class="string">&#x27;thisArg.func(&#x27;</span> + args +<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    <span class="keyword">delete</span> thisArg.<span class="property">func</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手撕bind【利用闭包】"><a href="#手撕bind【利用闭包】" class="headerlink" title="手撕bind【利用闭包】"></a>手撕bind【利用闭包】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params">context, ...args1</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> that = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> that.<span class="title function_">apply</span>(context,[...args1,...args2])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myName</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line">myName.<span class="title function_">myBind</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;meng&#x27;</span>&#125;)() <span class="comment">// meng</span></span><br></pre></td></tr></table></figure><p>ES5实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">meFunction.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">var</span> args1 = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>) <span class="comment">// slice 实现拷贝</span></span><br><span class="line"><span class="keyword">var</span> context = args1.<span class="title function_">splice</span>(<span class="number">0</span>,<span class="number">1</span>)[<span class="number">0</span>] <span class="comment">// splice 会改变原数组</span></span><br><span class="line"><span class="keyword">var</span> that = <span class="variable language_">this</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">var</span> args2 = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line"><span class="keyword">return</span> that.<span class="title function_">apply</span>(context,args1.<span class="title function_">concat</span>(args2))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myName</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line">myName.<span class="title function_">myBind</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;meng&#x27;</span>&#125;)() <span class="comment">// meng</span></span><br></pre></td></tr></table></figure><h2 id="手撕对象的冻结"><a href="#手撕对象的冻结" class="headerlink" title="手撕对象的冻结"></a>手撕对象的冻结</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">constantize</span> = (<span class="params">obj</span>) =&gt; &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj);</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>( <span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span> ) &#123;</span><br><span class="line">      <span class="title function_">constantize</span>( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="手撕Promise"><a href="#手撕Promise" class="headerlink" title="手撕Promise "></a><a href="https://juejin.cn/post/7032564107899322381">手撕Promise </a></h2><h2 id="手撕数组的深浅拷贝"><a href="#手撕数组的深浅拷贝" class="headerlink" title="手撕数组的深浅拷贝"></a>手撕数组的深浅拷贝</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浅拷贝</span></span><br><span class="line"><span class="keyword">var</span> arr = [&#123;<span class="attr">name</span>: <span class="string">&#x27;wens&#x27;</span>&#125;,&#123;<span class="attr">age</span>: <span class="string">&#x27;26&#x27;</span>&#125;];           <span class="comment">//原数组 </span></span><br><span class="line"><span class="keyword">var</span> newArr1 = arr;                                <span class="comment">//指向同一块堆地址</span></span><br><span class="line"><span class="keyword">var</span> newArr2 = arr.<span class="title function_">slice</span>();                        <span class="comment">//浅拷贝</span></span><br><span class="line"><span class="keyword">var</span> newArr3 = arr.<span class="title function_">concat</span>();                       <span class="comment">//浅拷贝</span></span><br><span class="line"><span class="keyword">var</span> newArr4 = [...arr]<span class="comment">//浅拷贝</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line"><span class="keyword">var</span> newArr4 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr));    <span class="comment">//深拷贝</span></span><br><span class="line"><span class="comment">//通用方法</span></span><br><span class="line"><span class="keyword">var</span> deepCopy = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 根据obj的类型判断是新建一个数组还是一个对象</span></span><br><span class="line">  <span class="keyword">var</span> newObj = obj <span class="keyword">instanceof</span> <span class="title class_">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// 遍历obj,并且判断是obj的属性才拷贝</span></span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      <span class="comment">// 判断属性值的类型，如果是对象递归调用深拷贝</span></span><br><span class="line">      newObj[key] = <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span> ? <span class="title function_">deepCopy</span>(obj[key]) : obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手撕节流函数和防抖函数"><a href="#手撕节流函数和防抖函数" class="headerlink" title="手撕节流函数和防抖函数"></a>手撕节流函数和防抖函数</h2><ul><li>防抖</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防抖</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> _debounce = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">fn</span>()</span><br><span class="line">        &#125;, delay) &#125;</span><br><span class="line">    <span class="keyword">return</span> _debounce</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>节流</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节流</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, interval</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> lastTime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> _throttle = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> nowTime = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">        <span class="comment">// console.log(new Date(nowTime));</span></span><br><span class="line">        <span class="keyword">const</span> remainTime = interval - (nowTime - lastTime)</span><br><span class="line">        <span class="keyword">if</span> (remainTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="title function_">fn</span>()</span><br><span class="line">            lastTime = nowTime</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _throttle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h2><p><a href="https://juejin.cn/post/7023944134561890318">牛客最新前端笔试题解析(一) this指向题目解析及扩展(juejin.cn)</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">var</span> foo = &#123; </span><br><span class="line">  <span class="attr">a</span>: <span class="number">20</span>, </span><br><span class="line">  <span class="attr">b</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">30</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span>; </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">c</span>: <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">40</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span>; </span><br><span class="line">  &#125;, </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> d = &#123; </span><br><span class="line">  <span class="attr">a</span>: <span class="number">50</span>, </span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">b</span>()); <span class="comment">//20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">c</span>()); <span class="comment">//10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">b</span>.<span class="title function_">bind</span>(d)()); <span class="comment">//50</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">c</span>.<span class="title function_">bind</span>(d)()); <span class="comment">//50 *** 10</span></span><br></pre></td></tr></table></figure><h2 id="apply，bind和call区别"><a href="#apply，bind和call区别" class="headerlink" title="apply，bind和call区别"></a>apply，bind和call区别</h2><p>apply：传入的是数组    原函数会立即执行，且此方法只是临时改变thi指向一次</p><p>call：传入的是参数列表    call也只是临时改变一次this指向，并立即执行</p><p>bind：第一参数也是this的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入，call则必须一次性传入所有参数)</p><p>但是它改变this指向后不会立即执行，而是返回一个永久改变this指向的函数。</p><p>总结</p><ul><li>三者都可以改变函数的this对象指向。</li><li>三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window。</li><li>三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入。</li><li>bind 是返回绑定this之后的函数，便于稍后调用；apply 、call 则是立即执行 。</li></ul><h2 id="闭包实现私有方法"><a href="#闭包实现私有方法" class="headerlink" title="闭包实现私有方法"></a>闭包实现私有方法</h2><h2 id="箭头函数与普通函数区别"><a href="#箭头函数与普通函数区别" class="headerlink" title="箭头函数与普通函数区别"></a>箭头函数与普通函数区别</h2><p>箭头函数不可以作为构造函数</p><p>没有this会从上下文中查找this</p><p>箭头函数不绑定arguments，取而代之用rest参数解决</p><p> 箭头函数不能使用<strong>yield</strong>命令</p><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><p>为了不影响主线程正常运行，就把那些耗时的时间（比如定时器，Ajax操作从网络读取数据等）任务挂起来，依次的放进一个任务队列中，等主线程的任务执行完毕后，再回过来去继续执行队列中的任务；</p><p><strong>提别强调：</strong></p><p>队列的优先级执行顺序为： 先执行同步和立即执行任务&gt;microtask&gt;macrotask</p><p><strong>宏任务包括</strong></p><p>会在一个(macro)task执行结束后，在下一个(macro)task 执行开始前，对页面进行重新渲染，<strong>执行时机是页面渲染之后</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------</span><br><span class="line">script(整体代码)</span><br><span class="line">setTimeout</span><br><span class="line">setInterval</span><br><span class="line">UI交互事件</span><br><span class="line">-------------------------------------</span><br><span class="line">I/O</span><br><span class="line"></span><br><span class="line">postMessage</span><br><span class="line">MessageChannel</span><br><span class="line">setImmediate(Node.js 环境)</span><br></pre></td></tr></table></figure><p><strong>微任务包括</strong> </p><p>所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染。也就是说，在某一个macrotask【宏】执行完后，就会将在它执行期间产生的所有microtask【微】都执行完毕（在渲染前）</p><p>有个笔试题的promise是微任务【个人感觉promise本身是同步任务，但是promise.then()是微任务】</p><p><strong>执行时机是页面渲染之前</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promise.then</span><br><span class="line">Object.observe</span><br><span class="line">MutationObserver</span><br><span class="line">process.nextTick(Node.js 环境)</span><br></pre></td></tr></table></figure><p><strong>事件循环机制</strong></p><p>对于 <code>Promise.all([])</code>，返回的 Promise 立即被解决，其 <code>then</code> 回调函数会在下一个微任务中执行，因为在当前任务队列中没有待执行的任务。因此，<code>console.log(&#39;all&#39;)</code> 会被输出。</p><p>对于 <code>Promise.race([])</code>，返回的 Promise 立即被解决，其 <code>then</code> 回调函数也会在下一个微任务中执行，因为在当前任务队列中没有待执行的任务。因此，<code>console.log(&#39;race&#39;)</code> 也会被执行。但是，由于空数组不包含任何待解决的 Promise，因此 <code>race</code> 不会发生竞争，<code>then</code> 回调函数会立即执行，输出 <code>race</code>。</p><p>例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;宏&#x27;</span>)&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span> (<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;微&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;宏&#x27;</span>)&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="comment">//输出结果是</span></span><br><span class="line">微</span><br><span class="line">宏</span><br><span class="line">宏</span><br><span class="line">---------------------</span><br><span class="line">    原因：promise内部是同步任务，先执行，然后两个<span class="built_in">setTimeout</span>是宏任务，后执行</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;宏&#x27;</span>)&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hong, promise&quot;</span>)&#125;).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;微&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;宏&#x27;</span>)&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">init.<span class="property">js</span>:<span class="number">1</span> hong, promise</span><br><span class="line">init.<span class="property">js</span>:<span class="number">1</span> 微</span><br><span class="line">init.<span class="property">js</span>:<span class="number">1</span> 宏</span><br><span class="line">init.<span class="property">js</span>:<span class="number">1</span> 宏</span><br><span class="line">---------------------</span><br><span class="line">    由此推断先执行同步任务 微任务 宏任务</span><br></pre></td></tr></table></figure><p>最后看一道笔试题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">沒了</span><br></pre></td></tr></table></figure><p>总结</p><p><img src="C:\Users\hang\AppData\Roaming\Typora\typora-user-images\image-20230326094412295.png" alt="image-20230326094412295"></p><p>1，7，6，8，2，4，3，5，9，11，10，12。</p><p>笔试题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;datagrand1&#x27;</span>); <span class="comment">//datagrand1</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;datagrand2&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;datagrand3&#x27;</span>); <span class="comment">//</span></span><br><span class="line">  <span class="title function_">resolve</span>(); </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;datagrand4&#x27;</span>); <span class="comment">//</span></span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;datagrand5&#x27;</span>); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;datagrand6&#x27;</span>); <span class="comment">//</span></span><br><span class="line">  <span class="title function_">resolve</span>(); </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">p2.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;datagrand7&#x27;</span>); <span class="comment">//</span></span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * datagrand1</span></span><br><span class="line"><span class="comment"> * datagrand5 *** datagrand3</span></span><br><span class="line"><span class="comment"> * datagrand3 *** datagrand5</span></span><br><span class="line"><span class="comment"> * datagrand6</span></span><br><span class="line"><span class="comment"> * datagrand4</span></span><br><span class="line"><span class="comment"> * datagrand7</span></span><br><span class="line"><span class="comment"> * datagrand2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">出错是因为我把同步任务谁先到谁先执行的原理忘了【一点小失误】</span><br></pre></td></tr></table></figure><p><strong>另外一道与立即执行函数和var变量相关的问题</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">  (<span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">  &#125;, i * <span class="number">1000</span>); </span><br><span class="line">  &#125;)(i); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5个5</p><p>变式（闭包问题）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">j</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(j);</span><br><span class="line">    &#125;, j * <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>0 1 2 3 4</p><h2 id="了解Generator吗"><a href="#了解Generator吗" class="headerlink" title="了解Generator吗"></a>了解Generator吗</h2><h2 id="js的预编译过程"><a href="#js的预编译过程" class="headerlink" title="js的预编译过程"></a>js的预编译过程</h2><h3 id="函数预编译-建立AO-Activation-Object"><a href="#函数预编译-建立AO-Activation-Object" class="headerlink" title="函数预编译(建立AO(Activation Object))"></a>函数预编译(建立<code>AO(Activation Object)</code>)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">变量提升（变量声明）</span><br><span class="line">形参传递</span><br><span class="line">函数定义</span><br><span class="line">执行</span><br></pre></td></tr></table></figure><h3 id="全局预编译-GO-Global-Object"><a href="#全局预编译-GO-Global-Object" class="headerlink" title="全局预编译(GO(Global Object))"></a>全局预编译(GO(Global Object))</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变量提升（变量声明）</span><br><span class="line">函数定义</span><br><span class="line">执行</span><br></pre></td></tr></table></figure><p>原文：<a href="https://juejin.cn/post/7019108835197452301">JavaScript之预编译学习(内含多个面试题) - 掘金 (juejin.cn)</a></p><h2 id="babel的执行过程"><a href="#babel的执行过程" class="headerlink" title="babel的执行过程"></a>babel的执行过程</h2><h2 id="ES6数组新增的方法find和flat（包括手撕）"><a href="#ES6数组新增的方法find和flat（包括手撕）" class="headerlink" title="ES6数组新增的方法find和flat（包括手撕）"></a>ES6数组新增的方法find和flat（包括手撕）</h2><h2 id="前端跨域问题及解决方案"><a href="#前端跨域问题及解决方案" class="headerlink" title="前端跨域问题及解决方案"></a>前端跨域问题及解决方案</h2><h3 id="深入问"><a href="#深入问" class="headerlink" title="深入问"></a>深入问</h3><p>script标签有哪些常用的属性：</p><ul><li>默认的type类型，会将script作为js语句块来对待</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>json类型，会将script作为一个数据块来对待</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;application/json&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="了解content-type字段吗"><a href="#了解content-type字段吗" class="headerlink" title="了解content-type字段吗"></a>了解content-type字段吗</h3><p>Content-Type表示内容类型和字符编码。内容类型也叫做MIME类型。</p><p>是服务器的响应头里面的一个字段常见的有</p><ul><li>Content-Type: application/json;</li><li>Content-Type: text/javascript;</li><li>Content-Type: text/html；charset=utf-8;【浏览器将会将响应的内容当做是一个<code>html</code>文件来解析处理】</li></ul><p>请求头</p><ul><li>application/x-www-form-urlencoded【<strong>表单提交</strong>】</li><li>multipart/form-data【<strong>文件上传</strong>】</li><li>application/json【前后端分离最常用】</li><li>text/xml</li></ul><p>响应头</p><ul><li><p>text/html ： HTML格式</p></li><li><p>text/plain ：纯文本格式</p></li><li><p>application/json：json格式</p></li><li><p>text/xml ： XML格式</p></li><li>image/gif ：gif图片格式<ul><li>image/jpeg ：jpg图片格式</li><li>image/png：png图片格式</li><li>application/pdf：pdf格式</li></ul></li><li><p>application/msword ： Word文档格式</p></li><li><p>application/octet-stream ： 二进制流数据（如常见的文件下载）</p></li></ul><h2 id="token和cookie的区别"><a href="#token和cookie的区别" class="headerlink" title="token和cookie的区别"></a>token和cookie的区别</h2><p><strong>那么 Cookie 的作用是什么呢：</strong></p><p>它的出现，就是来弥补 HTTP 无状态的问题的，Cookie 可以作为一个状态保存的状态机，用来保存用户的相关登录状态，当第一次验证通过后，服务器可以通过 set-cookie 令客户端将自己的 cookie  保存起来，当下一次再发送请求的时候，直接带上 cookie 即可，而服务器检测到客户端发送的 cookie 与其保存的 cookie 值保持一致时，则直接信任该连接，不再进行验证操作</p><p><strong>token的作用：</strong></p><p>Token，简单来说，就是类似 cookie 的一种验证信息，客户端通过登录验证后，服务器会返回给客户端一个加密的 token，然后当客户端再次向服务器发起连接时，带上token，服务器直接对token进行校验即可完成权限校验。</p><p>为了验证用户登录情况以及减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮</p><p>token出现原因：</p><ul><li>相较于 Cookie，token 需要自己存储，自己进行发送，不存在跨域限制，因此 Token 更加的灵活</li><li>cookie内存限制为4kb，token无内存限制</li><li>采用 Cookie 的话，由于所有用户都需要在服务器的 Session 中存储相对应的用户信息，token不需要</li><li>token往往存储在浏览器本地存储如localStorage里面</li></ul><h3 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h3><p>(1)cookie数据存放在客户的浏览器上，session数据放在服务器上<br>(2)cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session<br>(3)session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE<br>(4)单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。<br>(5)所以：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中</p><h3 id="Cookie-localStorage和SessionStorage区别"><a href="#Cookie-localStorage和SessionStorage区别" class="headerlink" title="Cookie,localStorage和SessionStorage区别"></a>Cookie,localStorage和SessionStorage区别</h3><p>localStorage和SessionStorage区别:</p><p><img src="C:\Users\hang\AppData\Roaming\Typora\typora-user-images\image-20230412194132682.png" alt="image-20230412194132682"></p><h2 id="单页应用和多页应用"><a href="#单页应用和多页应用" class="headerlink" title="单页应用和多页应用"></a>单页应用和多页应用</h2><p>单页应用</p><p>只有一张Web页面的应用，是一种从Web服务器加载的富客户端，单页面跳转仅刷新局部资源 ，公共资源(js、css等)仅需加载一次，常用于PC端官网、购物等网站</p><p>多页应用</p><p>多页面跳转刷新所有资源，每个公共资源(js、css等)需选择性重新加载，常用于 app 或 客户端等</p><p>具体对比分析：</p><div class="table-container"><table><thead><tr><th></th><th>单页面应用（SinglePage Web Application，SPA）</th><th>多页面应用（MultiPage Application，MPA）</th></tr></thead><tbody><tr><td>组成</td><td>一个外壳页面和多个页面片段组成</td><td>多个完整页面构成</td></tr><tr><td>资源共用(css,js)</td><td>共用，只需在外壳部分加载</td><td>不共用，每个页面都需要加载</td></tr><tr><td>刷新方式</td><td>页面局部刷新或更改</td><td>整页刷新</td></tr><tr><td>url 模式</td><td>a.com/#/pageone   a.com/#/pagetwo</td><td>a.com/pageone.html   a.com/pagetwo.html</td></tr><tr><td>用户体验</td><td>页面片段间的切换快，用户体验良好</td><td>页面切换加载缓慢，流畅度不够，用户体验比较差</td></tr><tr><td>转场动画</td><td>容易实现</td><td>无法实现</td></tr><tr><td>数据传递</td><td>容易</td><td>依赖 url传参、或者cookie 、localStorage等</td></tr><tr><td>搜索引擎优化(SEO)</td><td>需要单独方案、实现较为困难、不利于SEO检索 可利用服务器端渲染(SSR)优化</td><td>实现方法简易</td></tr><tr><td>试用范围</td><td>高要求的体验度、追求界面流畅的应用</td><td>适用于追求高度支持搜索引擎的应用</td></tr><tr><td>开发成本</td><td>较高，常需借助专业的框架</td><td>较低 ，但页面重复代码多</td></tr><tr><td>维护成本</td><td>相对容易</td><td>相对复杂</td></tr></tbody></table></div><h1 id="promise篇"><a href="#promise篇" class="headerlink" title="promise篇"></a>promise篇</h1><h1 id="性能优化篇"><a href="#性能优化篇" class="headerlink" title="性能优化篇"></a>性能优化篇</h1><h2 id="路由懒加载："><a href="#路由懒加载：" class="headerlink" title="路由懒加载："></a>路由懒加载：</h2><p>整个网页默认是刚打开就去加载所有页面，路由懒加载就是只加载你当前点击的那个模块。</p><p>按需去加载路由对应的资源，提高首屏加载速度（tip:首页不用设置懒加载，而且一个页面加载过后再次访问不会重复加载）。</p><p>实现原理：将路由相关的组件，不再直接导入了，而是改写成异步组件的写法，只有当函数被调用的时候，才去加载对应的组件内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>, <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/login/index.vue&#x27;</span>) &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/home/home.vue&#x27;</span>) &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h2 id="cdn加速"><a href="#cdn加速" class="headerlink" title="cdn加速"></a>cdn加速</h2><h1 id="前端安全篇"><a href="#前端安全篇" class="headerlink" title="前端安全篇"></a>前端安全篇</h1><p><a href="https://juejin.cn/post/7101144447743688712">前端网络安全&amp;防范方式 看完这篇就够了 - 掘金 (juejin.cn)</a></p><h2 id="csrf-Cross-site-request-forgery-跨站请求伪造"><a href="#csrf-Cross-site-request-forgery-跨站请求伪造" class="headerlink" title="csrf[Cross-site request forgery 跨站请求伪造]"></a>csrf[Cross-site request forgery 跨站请求伪造]</h2><p><a href="https://blog.csdn.net/l_ppp/article/details/106432572">(55条消息) Web前端安全策略之CSRF的攻击与防御_「零一」的博客-CSDN博客</a></p><p>攻击原理：跨站请求伪造，英文全称为Cross Site Request Forgery ， 缩写CSRF，这种攻击模式用通俗易懂的话来讲就是：攻击者借用你的用户身份，来完成一些需要依靠用户信息来完成的事情，例如转账 、发送邮件……</p><p>特征：</p><ul><li>攻击发起在第三方网站，而不是被攻击的网站。</li><li>攻击者是冒充受害者提交操作，而不是直接窃取用户信息数据</li><li>整个过程攻击者是没有获取到用户的 <code>Cookie</code> ，而是冒充</li><li>跨站攻击很难防范，因为都发生在第三方的网站</li></ul><p>解决方案：</p><ul><li>增加一个验证码， 服务端判断验证码是否正确</li><li>使用refer验证，同源检测</li><li>参数伪造 token</li><li>Cookie 安全设置 SameSite 同源检测，Cookie<code>设置了 SameSite=strict 则表示完全禁用第三方站点请求头携带</code>Cookie</li></ul><h2 id="XSS-跨站脚本攻击"><a href="#XSS-跨站脚本攻击" class="headerlink" title="XSS 跨站脚本攻击"></a>XSS 跨站脚本攻击</h2><ul><li>顾名思义 反射型 的 XSS 恶意脚本存在 URL 里面，存储 XSS 的代码是放在数据库里面的。</li><li>反射型 XSS 攻击通常通过 URL 传递参数的功能，例如网站或者恶意跳转</li><li>存储型 XSS 攻击 在 保存用户数据的网站，例如论坛发帖的时候，或者用户私信</li><li>而基于 DOM 的 XSS 攻击中，主要是因为浏览器端的出现的安全漏洞做成的，因为不需要通过请求服务器就能实现，另外两种是属于服务器端的安全漏洞</li></ul><p>解决方案：</p><p>加载脚本的方法,存在漏洞将一些不可预计的脚本加载到页面上</p><ul><li>.innerHTML</li><li>.outerHTML</li><li>document.write()</li></ul><p>Vue/React 技术栈，同样是原理，不过是换了 API 来实现方式</p><ul><li>v-html</li><li>dangerouslySetInnerHTML</li></ul><p>DOM 中的监听器</p><ul><li>location</li><li>onload</li><li>onclick</li><li>onerror</li></ul><p>定时器 和 eval 将一些不可信的字段拼接并且传递到 API</p><ul><li>setTimeout</li><li>setInterval</li><li>eval</li></ul><ol><li>永远不用在用户提交的内容上使用v-html【js中叫做innerHTML】</li><li>cookie设置SameSite同源检测【SameSite = strict 禁止第三方站点携带cookie】</li><li>输入验证 phone，URL，电话号码，邮箱</li><li>开启浏览器的 XSS防御：Http Only Cookie 浏览器的Cookies 在设置的时候 加入 <code>HttpOnly</code> 属性，禁止js代码读取cookie</li></ol><h2 id="CSP-内容安全策略"><a href="#CSP-内容安全策略" class="headerlink" title="CSP 内容安全策略"></a>CSP 内容安全策略</h2><ul><li>一个网站管理者想要所有内容均来自站点的同一个源 (不包括其子域名) 同源策略原则</li><li>所有脚本必须从特定主机服务器获取可信的代码 用户的数据不会发送到外域。禁止外域提交的操作</li><li>禁止使用内联脚本，禁止未授权的脚本执行</li></ul><p>具体使用【meta标签配置csp】</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; img-src https://*; child-src &#x27;none&#x27;;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="点击劫持-X-Frame-Options"><a href="#点击劫持-X-Frame-Options" class="headerlink" title="点击劫持 X-Frame-Options"></a>点击劫持 X-Frame-Options</h2><p>sandbox 属性 它对页面的操作施加限制，包括阻止弹出窗口、阻止插件和脚本的执行以及执行同源策略。主要针对 iFrame 合法使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: sandbox;</span><br><span class="line">Content-Security-Policy: sandbox <span class="tag">&lt;<span class="name">value</span>&gt;</span>;</span><br></pre></td></tr></table></figure><h2 id="form表单验证，阻止默认事件"><a href="#form表单验证，阻止默认事件" class="headerlink" title="form表单验证，阻止默认事件**"></a>form表单验证，阻止默认事件**</h2><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="vue实现绑定为何后面是字符串"><a href="#vue实现绑定为何后面是字符串" class="headerlink" title="vue实现绑定为何后面是字符串"></a>vue实现绑定为何后面是字符串</h2><ul><li><code>eval()</code>函数计算<code>JavaScript</code>字符串，并把它作为脚本代码来执行。</li></ul><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>函数参数的解构赋值那点不太能理解默认值那点</p><p>模板编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//   function aid(arr, depth)&#123;</span><br><span class="line">//     for (let k of arr)&#123;</span><br><span class="line">//       if (Array.isArray(k))&#123;</span><br><span class="line">//         aid(k, depth + 1);</span><br><span class="line">//       &#125;else&#123;</span><br><span class="line">//         count = Math.max(count, depth)</span><br><span class="line">//       &#125;</span><br><span class="line">//     &#125;</span><br><span class="line">//   &#125;</span><br><span class="line">//   aid(arr, 1);</span><br><span class="line">//   return count;</span><br><span class="line">// &#125;</span><br><span class="line">function getMaxDepth1(arr)&#123;</span><br><span class="line">  // let max = 1</span><br><span class="line">  let max = 1</span><br><span class="line">  let depth = 1</span><br><span class="line">  for (let i of arr)&#123;</span><br><span class="line">    if (Array.isArray(i))&#123;</span><br><span class="line">      depth = 1 + getMaxDepth1(i)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      max = Math.max(depth,max)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return max</span><br><span class="line">&#125;</span><br><span class="line">console.log(getMaxDepth1([[1], [[1, 2]], [[[[1, 2, 3]]]]]));</span><br><span class="line">console.log(getMaxDepth1([1,2,[3]]));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
